import { LocalStorageService, LocalStorageModule } from 'angular-2-local-storage';
import { HttpParams, HttpClient, HttpClientModule, HttpErrorResponse } from '@angular/common/http';
import { Router } from '@angular/router';
import { EventEmitter, Injectable, ɵɵdefineInjectable, ɵɵinject, Component, NgModule } from '@angular/core';
import { Validators, FormBuilder, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { BehaviorSubject, Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AccessTokenModel {
    /**
     * @param {?} token
     * @param {?} refreshToken
     * @param {?} expiration
     */
    constructor(token, refreshToken, expiration) {
        this.token = token;
        this.refreshToken = refreshToken;
        this.expiration = expiration;
    }
}
if (false) {
    /** @type {?} */
    AccessTokenModel.prototype.token;
    /** @type {?} */
    AccessTokenModel.prototype.refreshToken;
    /** @type {?} */
    AccessTokenModel.prototype.expiration;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// This file can be replaced during build by using the `fileReplacements` array.
// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.
// The list of file replacements can be found in `angular.json`.
/** @type {?} */
const environment = {
    production: false,
    apiURL: "https://api.columnis.com/",
    codeURI: "001/columnis/clients",
    oauthURI: '/oauth',
    userGroupsURI: '/columnis/user_groups',
    permissionsURI: '/columnis/permissions',
    usersURI: '/columnis/users'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthService {
    /**
     * @param {?} router
     * @param {?} httpClient
     * @param {?} localStorageService
     */
    constructor(router, httpClient, localStorageService) {
        this.router = router;
        this.httpClient = httpClient;
        this.localStorageService = localStorageService;
        this.searchingCode = new EventEmitter();
        this.codeNotFound = new EventEmitter();
    }
    /**
     * @return {?}
     */
    isAuthenticated() {
        /** @type {?} */
        let currentUser = this.localStorageService.get('access_token');
        if (currentUser) {
            return true;
        }
        ;
        return false;
    }
    /**
     * @param {?} email
     * @param {?} password
     * @return {?}
     */
    login(email, password) {
        /** @type {?} */
        let username = email.split("@");
        this.httpClient.post(environment.apiURL + this.codeDomain + environment.oauthURI, {
            "client_id": "columnis_manager",
            "grant_type": "password",
            "username": username[0],
            "password": password
        }).subscribe((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            this.localStorageService.set('code', this.codeDomain);
            this.localStorageService.set('access_token', response['access_token']);
            // this.localStorageService.set('refresh_token', response['refresh_token']);
            console.log("Logged in", response);
            this.router.navigate(['/']);
            this.accessToken = this.parseAccessToken(response);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            /** @type {?} */
            let message;
            // this.translateService.get('share.dialog.errorPassword').subscribe(response => {
            //     message = response;
            // });
            console.log(message);
            console.log(error.error.detail);
        }));
    }
    /**
     * @return {?}
     */
    logout() {
        // this.localStorageService.clearAll();
        this.localStorageService.remove('access_token');
        this.localStorageService.remove('code');
        this.router.navigate(['/oauth']);
    }
    /**
     * @return {?}
     */
    getAccessToken() {
        return this.localStorageService.get('access_token');
    }
    /**
     * @param {?} domain
     * @return {?}
     */
    setCode(domain) {
        this.searchingCode.emit(true);
        if (this.localStorageService.get(domain)) {
            console.log("desde ls");
            this.codeNotFound.emit(false);
            this.searchingCode.emit(false);
            this.codeDomain = this.localStorageService.get(domain);
        }
        else {
            /** @type {?} */
            let params = new HttpParams().set('domain', domain);
            this.httpClient.get(environment.apiURL + environment.codeURI, { params }).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.codeDomain = response.code;
                if (!((this.codeDomain) == '000')) {
                    this.localStorageService.set(domain, this.codeDomain);
                    this.searchingCode.emit(false); //si encuentra un codigo
                }
                else {
                    this.searchingCode.emit(false); //si no encuentra
                    this.codeNotFound.emit(true);
                }
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                this.searchingCode.emit(false); //si no encuentra
                this.codeNotFound.emit(true);
                console.log(error);
            }));
        }
    }
    /**
     * @return {?}
     */
    getCode() {
        return this.localStorageService.get('code');
    }
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    parseAccessToken(obj) {
        /** @type {?} */
        let accessToken = null;
        //Check access token
        if (obj && obj.access_token) {
            //parse expiration date
            /** @type {?} */
            let expiration = new Date();
            expiration.setMinutes(expiration.getMinutes() + (obj.expires_in / 60));
            //Creates the access token model
            accessToken = new AccessTokenModel(obj.access_token, obj.refresh_token, expiration);
        }
        console.log(accessToken);
        return accessToken;
    }
}
AuthService.decorators = [
    { type: Injectable, args: [{
                //duda
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AuthService.ctorParameters = () => [
    { type: Router },
    { type: HttpClient },
    { type: LocalStorageService }
];
/** @nocollapse */ AuthService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(ɵɵinject(Router), ɵɵinject(HttpClient), ɵɵinject(LocalStorageService)); }, token: AuthService, providedIn: "root" });
if (false) {
    /** @type {?} */
    AuthService.prototype.codeDomain;
    /** @type {?} */
    AuthService.prototype.searchingCode;
    /** @type {?} */
    AuthService.prototype.codeNotFound;
    /**
     * @type {?}
     * @private
     */
    AuthService.prototype.accessToken;
    /**
     * @type {?}
     * @private
     */
    AuthService.prototype.router;
    /**
     * @type {?}
     * @private
     */
    AuthService.prototype.httpClient;
    /**
     * @type {?}
     * @private
     */
    AuthService.prototype.localStorageService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SolcreAuthLibraryComponent {
    /**
     * @param {?} formBuilder
     * @param {?} authService
     */
    constructor(formBuilder, authService) {
        this.formBuilder = formBuilder;
        this.authService = authService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.signinForm = this.formBuilder.group({
            'email': this.formBuilder.control(null, [Validators.required, Validators.email]),
            'password': this.formBuilder.control(null, Validators.required)
        });
        this.authService.codeNotFound.subscribe((/**
         * @param {?} state
         * @return {?}
         */
        (state) => {
            this.codeNotFound = state;
        }));
        this.authService.searchingCode.subscribe((/**
         * @param {?} state
         * @return {?}
         */
        (state) => {
            this.searchingCode = state;
        }));
    }
    /**
     * @return {?}
     */
    onSubmit() {
        this.authService.login(this.signinForm.value.email, this.signinForm.value.password);
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.codeNotFound = false;
        this.searchingCode = false;
        this.signinForm.invalid;
        if (this.signinForm.value.email && this.signinForm.value.email.indexOf('@') > -1) {
            /** @type {?} */
            let data = (this.signinForm.value.email).split("@", 2);
            /** @type {?} */
            let domain = data[1];
            this.authService.setCode(domain);
        }
    }
}
SolcreAuthLibraryComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-auth-library',
                template: "<form \n    name=\"app-login-form\"\n    id=\"app-login-form\"\n    class=\"styled-form\" \n    [formGroup]=\"signinForm\" \n    (ngSubmit)=\"onSubmit()\">\n    <h1>Auth library</h1>\n    <div>\n        <input class=\"input\" type=\"text\" (blur)=\"onBlur()\" id=\"email\" formControlName=\"email\" name=\"email\"><br>\n    </div>\n    <label *ngIf=\"searchingCode\" for=\"email\">Buscando dominio...</label>\n    <label *ngIf=\"codeNotFound\" for=\"email\">*Error al encontrar dominio</label>\n    <div>\n        <input class=\"input\" type=\"password\" id=\"password\" formControlName=\"password\" name=\"password\"><br>\n    </div>\n    <button class=\"rounded-btn\" type=\"submit\">Entrar</button>\n</form>"
            }] }
];
/** @nocollapse */
SolcreAuthLibraryComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: AuthService }
];
if (false) {
    /** @type {?} */
    SolcreAuthLibraryComponent.prototype.signinForm;
    /** @type {?} */
    SolcreAuthLibraryComponent.prototype.searchingCode;
    /** @type {?} */
    SolcreAuthLibraryComponent.prototype.codeNotFound;
    /**
     * @type {?}
     * @private
     */
    SolcreAuthLibraryComponent.prototype.formBuilder;
    /**
     * @type {?}
     * @private
     */
    SolcreAuthLibraryComponent.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthModule {
}
AuthModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SolcreAuthLibraryComponent,
                ],
                imports: [
                    LocalStorageModule,
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                    ReactiveFormsModule,
                ],
                exports: [
                    SolcreAuthLibraryComponent
                ],
                providers: [
                    AuthService,
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthGuard {
    /**
     * @param {?} authService
     * @param {?} router
     */
    constructor(authService, router) {
        this.authService = authService;
        this.router = router;
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivate(route, state) {
        if (this.authService.isAuthenticated()) {
            return true;
        }
        else {
            this.router.navigate(['/oauth']);
        }
    }
}
AuthGuard.decorators = [
    { type: Injectable, args: [{
                //duda
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AuthGuard.ctorParameters = () => [
    { type: AuthService },
    { type: Router }
];
/** @nocollapse */ AuthGuard.ngInjectableDef = ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(ɵɵinject(AuthService), ɵɵinject(Router)); }, token: AuthGuard, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    AuthGuard.prototype.authService;
    /**
     * @type {?}
     * @private
     */
    AuthGuard.prototype.router;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// ​import { AccessTokenModel } from './access-token.model';
class AuthInterceptor {
    /**
     * @param {?} authService
     */
    constructor(authService) {
        this.authService = authService;
        this.isRefreshingToken = false;
        this.tokenSubject = new BehaviorSubject(null);
    }
    //Intercep method
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        // Pass on the cloned request instead of the original request.
        return (/** @type {?} */ (next.handle(req)
            .pipe(catchError((/**
         * @param {?} error
         * @param {?} caught
         * @return {?}
         */
        (error, caught) => {
            //Check error type
            if (error instanceof HttpErrorResponse) {
                console.log(error);
                switch (error.status) {
                    case 400:
                        return this.handle400Error(error);
                    case 401:
                        return this.handle401Error(error, req, next);
                    case 403:
                        return this.handle403Error(error);
                }
            }
            return new Observable();
        })))));
    }
    //Add authorization header to requests
    /**
     * @private
     * @param {?} req
     * @param {?} token
     * @return {?}
     */
    addToken(req, token) {
        return req.clone({
            setHeaders: {
                Authorization: 'Bearer ' + token
            }
        });
    }
    //Helper function when the refresh token doesnt work
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    logout(error) {
        //logout users, redirect to login page
        this.authService.logout();
        return throwError(error);
    }
    //Handle 403 error
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handle403Error(error) {
        return this.logout(error.message);
    }
    //Hanfle 401 error
    /**
     * @private
     * @param {?} error
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    handle401Error(error, req, next) {
        //@@TODO: find a way to configure it
        //Ignore 401 status when the url are Oauth
        if (req.url.indexOf('/oauth') > -1) {
            return throwError(error);
        }
        return this.logout(error.message);
    }
    //Handle 400 error
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handle400Error(error) {
        if (error
            && error.status === 400
            && error.error
            && error.error.error === 'invalid_grant') {
            // If we get a 400 and the error message is 'invalid_grant', the token is no longer valid so logout.
            return this.logout(error.message);
        }
        //Normal flow
        return throwError(error);
    }
}
AuthInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AuthInterceptor.ctorParameters = () => [
    { type: AuthService }
];
if (false) {
    /** @type {?} */
    AuthInterceptor.prototype.isRefreshingToken;
    /** @type {?} */
    AuthInterceptor.prototype.tokenSubject;
    /**
     * @type {?}
     * @private
     */
    AuthInterceptor.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AuthGuard, AuthInterceptor, AuthModule, AuthService, SolcreAuthLibraryComponent };
//# sourceMappingURL=ng-solcre-auth.js.map
