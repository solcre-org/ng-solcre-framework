(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('angular-2-local-storage'), require('@angular/common/http'), require('@angular/router'), require('@angular/core'), require('@angular/forms'), require('@angular/common'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ng-solcre-auth', ['exports', 'angular-2-local-storage', '@angular/common/http', '@angular/router', '@angular/core', '@angular/forms', '@angular/common', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory(global['ng-solcre-auth'] = {}, global.angular2LocalStorage, global.ng.common.http, global.ng.router, global.ng.core, global.ng.forms, global.ng.common, global.rxjs, global.rxjs.operators));
}(this, (function (exports, angular2LocalStorage, http, router, core, forms, common, rxjs, operators) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AccessTokenModel = /** @class */ (function () {
        function AccessTokenModel(token, refreshToken, expiration) {
            this.token = token;
            this.refreshToken = refreshToken;
            this.expiration = expiration;
        }
        return AccessTokenModel;
    }());
    if (false) {
        /** @type {?} */
        AccessTokenModel.prototype.token;
        /** @type {?} */
        AccessTokenModel.prototype.refreshToken;
        /** @type {?} */
        AccessTokenModel.prototype.expiration;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // This file can be replaced during build by using the `fileReplacements` array.
    // `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.
    // The list of file replacements can be found in `angular.json`.
    /** @type {?} */
    var environment = {
        production: false,
        apiURL: "https://api.columnis.com/",
        codeURI: "001/columnis/clients",
        oauthURI: '/oauth',
        userGroupsURI: '/columnis/user_groups',
        permissionsURI: '/columnis/permissions',
        usersURI: '/columnis/users'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AuthService = /** @class */ (function () {
        function AuthService(router, httpClient, localStorageService) {
            this.router = router;
            this.httpClient = httpClient;
            this.localStorageService = localStorageService;
            this.searchingCode = new core.EventEmitter();
            this.codeNotFound = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        AuthService.prototype.isAuthenticated = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var currentUser = this.localStorageService.get('access_token');
            if (currentUser) {
                return true;
            }
            ;
            return false;
        };
        /**
         * @param {?} email
         * @param {?} password
         * @return {?}
         */
        AuthService.prototype.login = /**
         * @param {?} email
         * @param {?} password
         * @return {?}
         */
        function (email, password) {
            var _this = this;
            /** @type {?} */
            var username = email.split("@");
            this.httpClient.post(environment.apiURL + this.codeDomain + environment.oauthURI, {
                "client_id": "columnis_manager",
                "grant_type": "password",
                "username": username[0],
                "password": password
            }).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                _this.localStorageService.set('code', _this.codeDomain);
                _this.localStorageService.set('access_token', response['access_token']);
                // this.localStorageService.set('refresh_token', response['refresh_token']);
                console.log("Logged in", response);
                _this.router.navigate(['/']);
                _this.accessToken = _this.parseAccessToken(response);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                /** @type {?} */
                var message;
                // this.translateService.get('share.dialog.errorPassword').subscribe(response => {
                //     message = response;
                // });
                console.log(message);
                console.log(error.error.detail);
            }));
        };
        /**
         * @return {?}
         */
        AuthService.prototype.logout = /**
         * @return {?}
         */
        function () {
            // this.localStorageService.clearAll();
            this.localStorageService.remove('access_token');
            this.localStorageService.remove('code');
            this.router.navigate(['/oauth']);
        };
        /**
         * @return {?}
         */
        AuthService.prototype.getAccessToken = /**
         * @return {?}
         */
        function () {
            return this.localStorageService.get('access_token');
        };
        /**
         * @param {?} domain
         * @return {?}
         */
        AuthService.prototype.setCode = /**
         * @param {?} domain
         * @return {?}
         */
        function (domain) {
            var _this = this;
            this.searchingCode.emit(true);
            if (this.localStorageService.get(domain)) {
                console.log("desde ls");
                this.codeNotFound.emit(false);
                this.searchingCode.emit(false);
                this.codeDomain = this.localStorageService.get(domain);
            }
            else {
                /** @type {?} */
                var params = new http.HttpParams().set('domain', domain);
                this.httpClient.get(environment.apiURL + environment.codeURI, { params: params }).subscribe((/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    _this.codeDomain = response.code;
                    if (!((_this.codeDomain) == '000')) {
                        _this.localStorageService.set(domain, _this.codeDomain);
                        _this.searchingCode.emit(false); //si encuentra un codigo
                    }
                    else {
                        _this.searchingCode.emit(false); //si no encuentra
                        _this.codeNotFound.emit(true);
                    }
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) {
                    _this.searchingCode.emit(false); //si no encuentra
                    _this.codeNotFound.emit(true);
                    console.log(error);
                }));
            }
        };
        /**
         * @return {?}
         */
        AuthService.prototype.getCode = /**
         * @return {?}
         */
        function () {
            return this.localStorageService.get('code');
        };
        /**
         * @private
         * @param {?} obj
         * @return {?}
         */
        AuthService.prototype.parseAccessToken = /**
         * @private
         * @param {?} obj
         * @return {?}
         */
        function (obj) {
            /** @type {?} */
            var accessToken = null;
            //Check access token
            if (obj && obj.access_token) {
                //parse expiration date
                /** @type {?} */
                var expiration = new Date();
                expiration.setMinutes(expiration.getMinutes() + (obj.expires_in / 60));
                //Creates the access token model
                accessToken = new AccessTokenModel(obj.access_token, obj.refresh_token, expiration);
            }
            console.log(accessToken);
            return accessToken;
        };
        AuthService.decorators = [
            { type: core.Injectable, args: [{
                        //duda
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        AuthService.ctorParameters = function () { return [
            { type: router.Router },
            { type: http.HttpClient },
            { type: angular2LocalStorage.LocalStorageService }
        ]; };
        /** @nocollapse */ AuthService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(core.ɵɵinject(router.Router), core.ɵɵinject(http.HttpClient), core.ɵɵinject(angular2LocalStorage.LocalStorageService)); }, token: AuthService, providedIn: "root" });
        return AuthService;
    }());
    if (false) {
        /** @type {?} */
        AuthService.prototype.codeDomain;
        /** @type {?} */
        AuthService.prototype.searchingCode;
        /** @type {?} */
        AuthService.prototype.codeNotFound;
        /**
         * @type {?}
         * @private
         */
        AuthService.prototype.accessToken;
        /**
         * @type {?}
         * @private
         */
        AuthService.prototype.router;
        /**
         * @type {?}
         * @private
         */
        AuthService.prototype.httpClient;
        /**
         * @type {?}
         * @private
         */
        AuthService.prototype.localStorageService;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SolcreAuthLibraryComponent = /** @class */ (function () {
        function SolcreAuthLibraryComponent(formBuilder, authService) {
            this.formBuilder = formBuilder;
            this.authService = authService;
        }
        /**
         * @return {?}
         */
        SolcreAuthLibraryComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.signinForm = this.formBuilder.group({
                'email': this.formBuilder.control(null, [forms.Validators.required, forms.Validators.email]),
                'password': this.formBuilder.control(null, forms.Validators.required)
            });
            this.authService.codeNotFound.subscribe((/**
             * @param {?} state
             * @return {?}
             */
            function (state) {
                _this.codeNotFound = state;
            }));
            this.authService.searchingCode.subscribe((/**
             * @param {?} state
             * @return {?}
             */
            function (state) {
                _this.searchingCode = state;
            }));
        };
        /**
         * @return {?}
         */
        SolcreAuthLibraryComponent.prototype.onSubmit = /**
         * @return {?}
         */
        function () {
            this.authService.login(this.signinForm.value.email, this.signinForm.value.password);
        };
        /**
         * @return {?}
         */
        SolcreAuthLibraryComponent.prototype.onBlur = /**
         * @return {?}
         */
        function () {
            this.codeNotFound = false;
            this.searchingCode = false;
            this.signinForm.invalid;
            if (this.signinForm.value.email && this.signinForm.value.email.indexOf('@') > -1) {
                /** @type {?} */
                var data = (this.signinForm.value.email).split("@", 2);
                /** @type {?} */
                var domain = data[1];
                this.authService.setCode(domain);
            }
        };
        SolcreAuthLibraryComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'lib-auth-library',
                        template: "<form \n    name=\"app-login-form\"\n    id=\"app-login-form\"\n    class=\"styled-form\" \n    [formGroup]=\"signinForm\" \n    (ngSubmit)=\"onSubmit()\">\n    <h1>Auth library</h1>\n    <div>\n        <input class=\"input\" type=\"text\" (blur)=\"onBlur()\" id=\"email\" formControlName=\"email\" name=\"email\"><br>\n    </div>\n    <label *ngIf=\"searchingCode\" for=\"email\">Buscando dominio...</label>\n    <label *ngIf=\"codeNotFound\" for=\"email\">*Error al encontrar dominio</label>\n    <div>\n        <input class=\"input\" type=\"password\" id=\"password\" formControlName=\"password\" name=\"password\"><br>\n    </div>\n    <button class=\"rounded-btn\" type=\"submit\">Entrar</button>\n</form>"
                    }] }
        ];
        /** @nocollapse */
        SolcreAuthLibraryComponent.ctorParameters = function () { return [
            { type: forms.FormBuilder },
            { type: AuthService }
        ]; };
        return SolcreAuthLibraryComponent;
    }());
    if (false) {
        /** @type {?} */
        SolcreAuthLibraryComponent.prototype.signinForm;
        /** @type {?} */
        SolcreAuthLibraryComponent.prototype.searchingCode;
        /** @type {?} */
        SolcreAuthLibraryComponent.prototype.codeNotFound;
        /**
         * @type {?}
         * @private
         */
        SolcreAuthLibraryComponent.prototype.formBuilder;
        /**
         * @type {?}
         * @private
         */
        SolcreAuthLibraryComponent.prototype.authService;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AuthModule = /** @class */ (function () {
        function AuthModule() {
        }
        AuthModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            SolcreAuthLibraryComponent,
                        ],
                        imports: [
                            angular2LocalStorage.LocalStorageModule,
                            common.CommonModule,
                            forms.FormsModule,
                            http.HttpClientModule,
                            forms.ReactiveFormsModule,
                        ],
                        exports: [
                            SolcreAuthLibraryComponent
                        ],
                        providers: [
                            AuthService,
                        ]
                    },] }
        ];
        return AuthModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AuthGuard = /** @class */ (function () {
        function AuthGuard(authService, router) {
            this.authService = authService;
            this.router = router;
        }
        /**
         * @param {?} route
         * @param {?} state
         * @return {?}
         */
        AuthGuard.prototype.canActivate = /**
         * @param {?} route
         * @param {?} state
         * @return {?}
         */
        function (route, state) {
            if (this.authService.isAuthenticated()) {
                return true;
            }
            else {
                this.router.navigate(['/oauth']);
            }
        };
        AuthGuard.decorators = [
            { type: core.Injectable, args: [{
                        //duda
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        AuthGuard.ctorParameters = function () { return [
            { type: AuthService },
            { type: router.Router }
        ]; };
        /** @nocollapse */ AuthGuard.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(core.ɵɵinject(AuthService), core.ɵɵinject(router.Router)); }, token: AuthGuard, providedIn: "root" });
        return AuthGuard;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        AuthGuard.prototype.authService;
        /**
         * @type {?}
         * @private
         */
        AuthGuard.prototype.router;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // ​import { AccessTokenModel } from './access-token.model';
    var AuthInterceptor = /** @class */ (function () {
        function AuthInterceptor(authService) {
            this.authService = authService;
            this.isRefreshingToken = false;
            this.tokenSubject = new rxjs.BehaviorSubject(null);
        }
        //Intercep method
        //Intercep method
        /**
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        AuthInterceptor.prototype.intercept = 
        //Intercep method
        /**
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        function (req, next) {
            var _this = this;
            // Pass on the cloned request instead of the original request.
            return (/** @type {?} */ (next.handle(req)
                .pipe(operators.catchError((/**
             * @param {?} error
             * @param {?} caught
             * @return {?}
             */
            function (error, caught) {
                //Check error type
                if (error instanceof http.HttpErrorResponse) {
                    console.log(error);
                    switch (error.status) {
                        case 400:
                            return _this.handle400Error(error);
                        case 401:
                            return _this.handle401Error(error, req, next);
                        case 403:
                            return _this.handle403Error(error);
                    }
                }
                return new rxjs.Observable();
            })))));
        };
        //Add authorization header to requests
        //Add authorization header to requests
        /**
         * @private
         * @param {?} req
         * @param {?} token
         * @return {?}
         */
        AuthInterceptor.prototype.addToken = 
        //Add authorization header to requests
        /**
         * @private
         * @param {?} req
         * @param {?} token
         * @return {?}
         */
        function (req, token) {
            return req.clone({
                setHeaders: {
                    Authorization: 'Bearer ' + token
                }
            });
        };
        //Helper function when the refresh token doesnt work
        //Helper function when the refresh token doesnt work
        /**
         * @private
         * @param {?} error
         * @return {?}
         */
        AuthInterceptor.prototype.logout = 
        //Helper function when the refresh token doesnt work
        /**
         * @private
         * @param {?} error
         * @return {?}
         */
        function (error) {
            //logout users, redirect to login page
            this.authService.logout();
            return rxjs.throwError(error);
        };
        //Handle 403 error
        //Handle 403 error
        /**
         * @private
         * @param {?} error
         * @return {?}
         */
        AuthInterceptor.prototype.handle403Error = 
        //Handle 403 error
        /**
         * @private
         * @param {?} error
         * @return {?}
         */
        function (error) {
            return this.logout(error.message);
        };
        //Hanfle 401 error
        //Hanfle 401 error
        /**
         * @private
         * @param {?} error
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        AuthInterceptor.prototype.handle401Error = 
        //Hanfle 401 error
        /**
         * @private
         * @param {?} error
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        function (error, req, next) {
            //@@TODO: find a way to configure it
            //Ignore 401 status when the url are Oauth
            if (req.url.indexOf('/oauth') > -1) {
                return rxjs.throwError(error);
            }
            return this.logout(error.message);
        };
        //Handle 400 error
        //Handle 400 error
        /**
         * @private
         * @param {?} error
         * @return {?}
         */
        AuthInterceptor.prototype.handle400Error = 
        //Handle 400 error
        /**
         * @private
         * @param {?} error
         * @return {?}
         */
        function (error) {
            if (error
                && error.status === 400
                && error.error
                && error.error.error === 'invalid_grant') {
                // If we get a 400 and the error message is 'invalid_grant', the token is no longer valid so logout.
                return this.logout(error.message);
            }
            //Normal flow
            return rxjs.throwError(error);
        };
        AuthInterceptor.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        AuthInterceptor.ctorParameters = function () { return [
            { type: AuthService }
        ]; };
        return AuthInterceptor;
    }());
    if (false) {
        /** @type {?} */
        AuthInterceptor.prototype.isRefreshingToken;
        /** @type {?} */
        AuthInterceptor.prototype.tokenSubject;
        /**
         * @type {?}
         * @private
         */
        AuthInterceptor.prototype.authService;
    }

    exports.AuthGuard = AuthGuard;
    exports.AuthInterceptor = AuthInterceptor;
    exports.AuthModule = AuthModule;
    exports.AuthService = AuthService;
    exports.SolcreAuthLibraryComponent = SolcreAuthLibraryComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ng-solcre-auth.umd.js.map
